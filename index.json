{"project": "ffsim", "project_url": "https://github.com/qiskit-community/ffsim", "show_commit_url": "http://github.com/qiskit-community/ffsim/commit/", "hash_length": 8, "revision_to_hash": {"293": "7d8b51d1ee51b679290957edc02a450a00de8b89", "294": "6d0fbe0a170b7f6b50c5efa334e081e6ffec8134", "295": "a3f70e6a67800f3317144868056ee9ee61186911", "328": "f4705dc9a7c570a6a8bd522e7d54c9a151cd4df0", "337": "e595ca8acf92f2ad9f8a2ef65ca05c567bda84a4", "357": "e4d9c76d85bc48ab9ec62996d60f2e20f8357461", "372": "702916704a5a0841fc91d5c1457e44d85b189265", "397": "237c46fc3a1107d3aa4c9d06d187880442052142", "427": "3bd709cd803c49a9f99739e5d4236c7ec31cd7aa", "490": "80ceaca50d45c5a181e812aeff78c1b7ed9b0a44", "633": "f18b63d8a50c147179d5d14af630576b5fc8cdab", "646": "f2071476f42524e609d57469291abb50206ca491", "650": "e8c991f1840c03af713e76643f2c157245104393", "656": "b3590ab0f85de6ce3fbea2274af9a20098189c0a", "692": "f064a1e6e92a7f7de5f68cc8bcb941a9bda255f0", "733": "6349a7b338b6863f02c7658e4f52ea64ff038727", "756": "28f43bd5a2b2f369def33841d61fee4e02832d45", "784": "b8eceda4a938e816f9307cc73742f03b3ac66b6e", "838": "4dda2db86a82ba8b74b21a62d8a896ceaa3832a4", "861": "f66d3523e0a755c719ed152a91cb7320962ba7b2", "868": "067a7844a983e412cb328ac6736dd3987339b742", "877": "97461210adcf09bc994432f69a27c499359417f4", "934": "350c9fdc03f8a16e582f3f66c87d2d936f8116fd", "944": "80bd11b0d27eb1e2fd9be35ef9b0851d5647a68a", "979": "dfba40616bb34d13705733c21ca3e75df757c8ae", "1023": "e46f74e12007fe3bb8414dbc8eba96be2a21163d", "1073": "39734435d54674e19b5336512c8a16bf0c3311c1", "1112": "4144571e8134e4d8321041763122fcb1d0ba115b", "1148": "30177afbcebf6f027034b9cc15cc56cb9f0ed597", "1310": "05ad80d3dee4dd19d48aa9465eb260822da75de0", "1326": "ab6083c90f08e517caaa2188c332a054ab768678", "1362": "a8354b8636c409802bd572acf00f1118228b6bbe", "1384": "e8c0bfc796d592dd9c82de61b030987b36400ac4", "1399": "762f435f5ba2045be1f7ec305e6b488daf8caa6d", "1426": "91ff7433cb347492a098716a5af4f14624456fc6", "1609": "0542fbdabf8e12a187a6d73a198e911001cd31ec", "1678": "fff9d13fffeb9fd3eb1d6c6c7ddc5070ca5df102", "1680": "edb09649fa53e739b741a506e5a7e21f1c1dcc25", "1682": "e24927c3c1fa8e6ea36d60d5596b913575470d39", "1684": "af595fed3d5d6efe7de081ffbc44857a2df4b4a9", "1686": "1e555245473a7ba7e94b8324847417a0e4081bf3", "1688": "2abe80a21f7bae82ac559e1cb5b1ea672d2fd8e5", "1692": "a62c5e5b224a13aadf67403a6055c777097c6fe9", "1694": "ec1029425228c916a5a47c0650a76d99b0d05701", "1698": "ec4fc6ce4468a11e14611a4d8d1d71312eda0e35", "1700": "577720f13ec41cbbd8fc0dda9cebd4e99e9fe4fc", "1714": "f2a0d339c0320a143935c6d2eb1ea019672b16fe"}, "revision_to_date": {"293": 1692665093000, "294": 1692668288000, "295": 1692670808000, "328": 1693964591000, "337": 1694007721000, "357": 1695003949000, "372": 1695231818000, "397": 1695399632000, "427": 1697313998000, "490": 1697823867000, "633": 1699029978000, "646": 1699227346000, "650": 1699228584000, "656": 1699277769000, "692": 1699382827000, "733": 1700250850000, "756": 1701743240000, "784": 1702320868000, "838": 1704392793000, "861": 1704924844000, "868": 1705089971000, "877": 1705261893000, "934": 1710994045000, "944": 1711323737000, "979": 1711589804000, "1023": 1711728342000, "1073": 1712112410000, "1112": 1712669884000, "1148": 1713075885000, "1310": 1714617766000, "1326": 1714757701000, "1362": 1715564877000, "1384": 1715650706000, "1399": 1715659921000, "1426": 1715961426000, "1609": 1717165489000, "1678": 1717355122000, "1680": 1717356334000, "1682": 1717369274000, "1684": 1717370299000, "1686": 1717370714000, "1688": 1717371572000, "1692": 1717377743000, "1694": 1717380616000, "1698": 1717382303000, "1700": 1717383920000, "1714": 1717553871000}, "params": {"arch": ["x86_64"], "cpu": ["Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz"], "machine": ["li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com"], "num_cpu": ["8"], "os": ["Linux 6.5.5-200.fc38.x86_64"], "ram": ["16013132"], "python": ["3.12"], "fqe": [""], "openfermion": [""], "qiskit-aer": [""], "env-RAYON_NUM_THREADS": ["1"], "env-OMP_NUM_THREADS": ["1"], "env-OPENBLAS_NUM_THREADS": ["1"], "env-MKL_NUM_THREADS": ["1"], "branch": ["main"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz", "machine": "li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com", "num_cpu": "8", "os": "Linux 6.5.5-200.fc38.x86_64", "ram": "16013132", "python": "3.12", "fqe": "", "openfermion": "", "qiskit-aer": "", "env-RAYON_NUM_THREADS": "1", "env-OMP_NUM_THREADS": "1", "env-OPENBLAS_NUM_THREADS": "1", "env-MKL_NUM_THREADS": "1", "branch": "main"}], "benchmarks": {"fermion_operator.FermionOperatorBenchmark.time_normal_order_ffsim": {"code": "class FermionOperatorBenchmark:\n    def time_normal_order_ffsim(self):\n        self.op_ffsim.normal_ordered()\n\n    def setup(self):\n        self.op_ffsim = random_fermion_operator(norb=50, n_terms=100, seed=4142)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)", "min_run_count": 2, "name": "fermion_operator.FermionOperatorBenchmark.time_normal_order_ffsim", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "355e202ad02eb710b9acb0b6033eb47d47c1120351f071b81d15b929666cc2cd", "warmup_time": -1}, "fermion_operator.FermionOperatorBenchmark.time_normal_order_openfermion": {"code": "class FermionOperatorBenchmark:\n    def time_normal_order_openfermion(self):\n        of.normal_ordered(self.op_openfermion)\n\n    def setup(self):\n        self.op_ffsim = random_fermion_operator(norb=50, n_terms=100, seed=4142)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)", "min_run_count": 2, "name": "fermion_operator.FermionOperatorBenchmark.time_normal_order_openfermion", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "4a631b10b71d419909df9ecdd5bbf8ff82897b5a1b1ac6119a0ca7526b7454d1", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_diag_coulomb_evolution_ffsim": {"code": "class GatesBenchmark:\n    def time_apply_diag_coulomb_evolution_ffsim(self, *_):\n        ffsim.apply_diag_coulomb_evolution(\n            self.vec,\n            self.diag_coulomb_mat,\n            time=1.0,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_diag_coulomb_evolution_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "a03fab793f33a8d7f934c8298f0275632318366888129336490c37bd5dd1ce11", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_givens_rotation_ffsim": {"code": "class GatesBenchmark:\n    def time_apply_givens_rotation_ffsim(self, *_):\n        ffsim.apply_givens_rotation(\n            self.vec,\n            theta=1.0,\n            target_orbs=(0, 2),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_givens_rotation_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "3792facaa9b69d3252e1c972aa31f9d16d0522065a9e5af8bcdc6fe5f9a711e4", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_interaction_ffsim": {"code": "class GatesBenchmark:\n    def time_apply_num_interaction_ffsim(self, *_):\n        ffsim.apply_num_interaction(\n            self.vec,\n            theta=1.0,\n            target_orb=1,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_interaction_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "b6797588a4635f3d8b43a1d3342d33472fe23d70774b80cc2d50ec3d5239f8cd", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_num_interaction_ffsim": {"code": "class GatesBenchmark:\n    def time_apply_num_num_interaction_ffsim(self, *_):\n        ffsim.apply_num_num_interaction(\n            self.vec,\n            theta=1.0,\n            target_orbs=(1, 2),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_num_interaction_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "850df41bee19d04751f63fd39465a62a0d34c14a31c305215fa35fa965285532", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_op_prod_interaction_ffsim": {"code": "class GatesBenchmark:\n    def time_apply_num_op_prod_interaction_ffsim(self, *_):\n        ffsim.apply_num_op_prod_interaction(\n            self.vec,\n            theta=1.0,\n            target_orbs=([1], [0]),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_op_prod_interaction_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "27ff72f8936edba238a107d9bcf367d459b5f1a9bf1f998519c087761f878d54", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_op_sum_evolution_ffsim": {"code": "class GatesBenchmark:\n    def time_apply_num_op_sum_evolution_ffsim(self, *_):\n        ffsim.apply_num_op_sum_evolution(\n            self.vec,\n            self.orbital_energies,\n            time=1.0,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_op_sum_evolution_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "edb93b867190c31273d37c5287486e48d897c55c67261a6c70ce2116427724b8", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_on_site_interaction_ffsim": {"code": "class GatesBenchmark:\n    def time_apply_on_site_interaction_ffsim(self, *_):\n        ffsim.apply_on_site_interaction(\n            self.vec,\n            theta=1.0,\n            target_orb=1,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_on_site_interaction_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "480156cf673c0d94107ce57af8fb496afe6deb3be4c812cd30cb449a04bcfe0e", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_tunneling_interaction_ffsim": {"code": "class GatesBenchmark:\n    def time_apply_tunneling_interaction_ffsim(self, *_):\n        ffsim.apply_tunneling_interaction(\n            self.vec,\n            theta=1.0,\n            target_orbs=(0, 2),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_tunneling_interaction_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "450b49fd762817d30c8e1097d3f0a437006cb3233a6d35b9d915d339dbb7cfe8", "warmup_time": -1}, "linear_operator.LinearOperatorBenchmark.time_molecular_hamiltonian_ffsim": {"code": "class LinearOperatorBenchmark:\n    def time_molecular_hamiltonian_ffsim(self, *_):\n        _ = self.mol_hamiltonian_linop @ self.vec\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            norb, seed=rng, dtype=float\n        )\n        constant = rng.standard_normal()\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor,\n            two_body_tensor=two_body_tensor,\n            constant=constant,\n        )\n        self.mol_hamiltonian_linop = ffsim.linear_operator(\n            mol_hamiltonian, norb=norb, nelec=self.nelec\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "linear_operator.LinearOperatorBenchmark.time_molecular_hamiltonian_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "52b98ffb1a19dc1d6166ae71be26fd276cc002fbfd4d8d1ecb355b892d3ca287", "warmup_time": -1}, "operator_action.OperatorActionBenchmark.time_operator_action_ffsim": {"code": "class OperatorActionBenchmark:\n    def time_operator_action_ffsim(self, *_):\n        _ = self.linop_ffsim @ self.vec_ffsim\n\n    def setup(self, norb: int, filling_fraction: float):\n        rng = np.random.default_rng(5853)\n    \n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        self.vec_ffsim = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec)\n        )\n        self.wfn_fqe = ffsim_vec_to_fqe_wfn(\n            self.vec_ffsim, norb=self.norb, nelec=self.nelec\n        )\n        self.op_ffsim = random_fermion_hamiltonian(norb=norb, n_terms=50, seed=rng)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)\n        self.linop_ffsim = ffsim.linear_operator(\n            self.op_ffsim, norb=self.norb, nelec=self.nelec\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "operator_action.OperatorActionBenchmark.time_operator_action_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "f798af13b366fe3065a4d4c12f168d3ace182477ce62cd8ff7894ac8c742d8fa", "warmup_time": -1}, "operator_action.OperatorActionBenchmark.time_operator_action_fqe": {"code": "class OperatorActionBenchmark:\n    def time_operator_action_fqe(self, *_):\n        _ = self.wfn_fqe.apply(self.op_openfermion)\n\n    def setup(self, norb: int, filling_fraction: float):\n        rng = np.random.default_rng(5853)\n    \n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        self.vec_ffsim = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec)\n        )\n        self.wfn_fqe = ffsim_vec_to_fqe_wfn(\n            self.vec_ffsim, norb=self.norb, nelec=self.nelec\n        )\n        self.op_ffsim = random_fermion_hamiltonian(norb=norb, n_terms=50, seed=rng)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)\n        self.linop_ffsim = ffsim.linear_operator(\n            self.op_ffsim, norb=self.norb, nelec=self.nelec\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "operator_action.OperatorActionBenchmark.time_operator_action_fqe", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "049aeb244d5c067b04b477f93c93b15e54b1733b1f280ee1879421b14d9e7c7e", "warmup_time": -1}, "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_ffsim": {"code": "class OrbitalRotationBenchmark:\n    def time_apply_orbital_rotation_ffsim(self, *_):\n        ffsim.apply_orbital_rotation(\n            self.vec,\n            self.orbital_rotation,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.orbital_rotation = ffsim.random.random_unitary(norb, seed=rng)\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            register = QuantumRegister(2 * norb)\n            circuit = QuantumCircuit(register)\n            circuit.set_statevector(initial_state)\n            circuit.append(\n                ffsim.qiskit.OrbitalRotationJW(norb, self.orbital_rotation), register\n            )\n            circuit.save_state()\n            self.orbital_rotation_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "17ef7495705e50d3627bd3d0058e451592d9ca564e16cd0ca226c7648d4470b1", "warmup_time": -1}, "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_fqe": {"code": "class OrbitalRotationBenchmark:\n    @skip_for_params([(16, 0.5)])\n    def time_apply_orbital_rotation_fqe(self, *_):\n        evolve_fqe_givens(self.vec_fqe, self.orbital_rotation)\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.orbital_rotation = ffsim.random.random_unitary(norb, seed=rng)\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            register = QuantumRegister(2 * norb)\n            circuit = QuantumCircuit(register)\n            circuit.set_statevector(initial_state)\n            circuit.append(\n                ffsim.qiskit.OrbitalRotationJW(norb, self.orbital_rotation), register\n            )\n            circuit.save_state()\n            self.orbital_rotation_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_fqe", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "642e6e64c154381c95398aee5aa8f054e7cdacc40f0b66c3057ba0a5df20b09e", "warmup_time": -1}, "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_qiskit": {"code": "class OrbitalRotationBenchmark:\n    @skip_for_params([(16, 0.25), (16, 0.5)])\n    def time_apply_orbital_rotation_qiskit(self, *_):\n        self.aer_sim.run(self.orbital_rotation_circuit).result()\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.orbital_rotation = ffsim.random.random_unitary(norb, seed=rng)\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            register = QuantumRegister(2 * norb)\n            circuit = QuantumCircuit(register)\n            circuit.set_statevector(initial_state)\n            circuit.append(\n                ffsim.qiskit.OrbitalRotationJW(norb, self.orbital_rotation), register\n            )\n            circuit.save_state()\n            self.orbital_rotation_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_qiskit", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "310cf637fcb9e358b371586b9be785f37c3ec1bd916dad76611866b1c429cd1d", "warmup_time": -1}, "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_ffsim": {"code": "class QuadHamEvoBenchmark:\n    def time_quad_ham_evolution_ffsim(self, *_):\n        ffsim.apply_num_op_sum_evolution(\n            self.vec,\n            self.orbital_energies,\n            time=1.0,\n            norb=self.norb,\n            nelec=self.nelec,\n            orbital_rotation=self.orbital_rotation,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        self.fqe_ham = RestrictedHamiltonian((self.one_body_tensor,))\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            circuit = num_op_sum_evo_circuit(\n                self.orbital_energies,\n                initial_state,\n                1.0,\n                norb=norb,\n                orbital_rotation=self.orbital_rotation,\n            )\n            self.quad_ham_evo_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "d7ae92a3db732b52670733514434cf9399f84d1de2323f9339f7793553ebffc9", "warmup_time": -1}, "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_fqe": {"code": "class QuadHamEvoBenchmark:\n    def time_quad_ham_evolution_fqe(self, *_):\n        self.vec_fqe.time_evolve(1.0, self.fqe_ham)\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        self.fqe_ham = RestrictedHamiltonian((self.one_body_tensor,))\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            circuit = num_op_sum_evo_circuit(\n                self.orbital_energies,\n                initial_state,\n                1.0,\n                norb=norb,\n                orbital_rotation=self.orbital_rotation,\n            )\n            self.quad_ham_evo_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_fqe", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "28ef76daa318213970c7ab4ae0eac7220dc9009c190fb07e2d70a6e38d95474d", "warmup_time": -1}, "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_qiskit": {"code": "class QuadHamEvoBenchmark:\n    @skip_for_params([(16, 0.25), (16, 0.5)])\n    def time_quad_ham_evolution_qiskit(self, *_):\n        self.aer_sim.run(self.quad_ham_evo_circuit).result()\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        self.fqe_ham = RestrictedHamiltonian((self.one_body_tensor,))\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            circuit = num_op_sum_evo_circuit(\n                self.orbital_energies,\n                initial_state,\n                1.0,\n                norb=norb,\n                orbital_rotation=self.orbital_rotation,\n            )\n            self.quad_ham_evo_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_qiskit", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "c57ac82719d2a2f7c30ebff90dd283586b04b232cc2d7f205ed7549045000d0c", "warmup_time": -1}, "rust.RustBenchmark.time_apply_givens_rotation_in_place_python_ffsim": {"code": "class RustBenchmark:\n    def time_apply_givens_rotation_in_place_python_ffsim(self, *_):\n        apply_givens_rotation_in_place_slow(\n            self.vec_as_mat,\n            c=0.5,\n            s=(1j) ** 0.5 * np.sqrt(0.75),\n            slice1=self.slice1,\n            slice2=self.slice2,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        rng = np.random.default_rng()\n    \n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_as_mat = self.vec.reshape((dim_a, dim_b))\n    \n        indices = _zero_one_subspace_indices(self.norb, self.nelec[0], (1, 2))\n        self.slice1 = indices[: len(indices) // 2]\n        self.slice2 = indices[len(indices) // 2 :]", "min_run_count": 2, "name": "rust.RustBenchmark.time_apply_givens_rotation_in_place_python_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "9dfa5df14081901bf570eb03ab418a917bbaf9f0edf472076a2baeb44d94bfc5", "warmup_time": -1}, "rust.RustBenchmark.time_apply_givens_rotation_in_place_rust_ffsim": {"code": "class RustBenchmark:\n    def time_apply_givens_rotation_in_place_rust_ffsim(self, *_):\n        apply_givens_rotation_in_place(\n            self.vec_as_mat,\n            c=0.5,\n            s=(1j) ** 0.5 * np.sqrt(0.75),\n            slice1=self.slice1,\n            slice2=self.slice2,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        rng = np.random.default_rng()\n    \n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_as_mat = self.vec.reshape((dim_a, dim_b))\n    \n        indices = _zero_one_subspace_indices(self.norb, self.nelec[0], (1, 2))\n        self.slice1 = indices[: len(indices) // 2]\n        self.slice2 = indices[len(indices) // 2 :]", "min_run_count": 2, "name": "rust.RustBenchmark.time_apply_givens_rotation_in_place_rust_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "69c213332bf9ce02e666f7edefcfeaa9848a0663a654291b4245cbb0c0935a2c", "warmup_time": -1}, "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_ffsim": {"code": "class TrotterBenchmark:\n    def time_simulate_trotter_double_factorized_ffsim(self, *_):\n        ffsim.simulate_trotter_double_factorized(\n            self.vec,\n            self.df_hamiltonian,\n            self.time,\n            norb=self.norb,\n            nelec=self.nelec,\n            n_steps=self.n_steps,\n            order=0,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        self.time = 1.0\n        self.n_steps = 3\n        rank = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            self.norb, rank=rank, seed=rng, dtype=float\n        )\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor, two_body_tensor=two_body_tensor\n        )\n        self.df_hamiltonian = (\n            ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian(\n                mol_hamiltonian, max_vecs=rank\n            )\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        self.vec_fqe = fqe.Wavefunction([[n_alpha + n_beta, n_alpha - n_beta, norb]])\n        self.vec_fqe.set_wfn(strategy=\"hartree-fock\")\n        low_rank_trotter = LowRankTrotter(\n            oei=one_body_tensor,\n            tei=np.asarray(two_body_tensor.transpose(0, 2, 3, 1), order=\"C\"),\n        )\n        (\n            self.basis_change_unitaries,\n            self.diag_coulomb_mats,\n        ) = low_rank_trotter.prepare_trotter_sequence(self.time)\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                ffsim.hartree_fock_state(self.norb, self.nelec),\n                norb=self.norb,\n                nelec=self.nelec,\n            )\n            qubits = QuantumRegister(2 * norb)\n            trotter_step = AsymmetricLowRankTrotterStepJW(qubits, self.df_hamiltonian)\n            circuit = QuantumCircuit(qubits)\n            circuit.set_statevector(initial_state)\n            for instruction in simulate_trotter(\n                trotter_step,\n                self.time,\n                n_steps=self.n_steps,\n            ):\n                circuit.append(instruction)\n            circuit.save_state()\n            self.circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "458d1e0415beee8b7098bf0aecf3f7a3021bc9895d483b91421c4148f978eb5f", "warmup_time": -1}, "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_fqe": {"code": "class TrotterBenchmark:\n    @skip_for_params([(16, 0.5)])\n    def time_simulate_trotter_double_factorized_fqe(self, *_):\n        simulate_trotter_double_factorized_fqe(\n            self.vec_fqe,\n            time=self.time,\n            n_steps=self.n_steps,\n            basis_change_unitaries=self.basis_change_unitaries,\n            diag_coulomb_mats=self.diag_coulomb_mats,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        self.time = 1.0\n        self.n_steps = 3\n        rank = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            self.norb, rank=rank, seed=rng, dtype=float\n        )\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor, two_body_tensor=two_body_tensor\n        )\n        self.df_hamiltonian = (\n            ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian(\n                mol_hamiltonian, max_vecs=rank\n            )\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        self.vec_fqe = fqe.Wavefunction([[n_alpha + n_beta, n_alpha - n_beta, norb]])\n        self.vec_fqe.set_wfn(strategy=\"hartree-fock\")\n        low_rank_trotter = LowRankTrotter(\n            oei=one_body_tensor,\n            tei=np.asarray(two_body_tensor.transpose(0, 2, 3, 1), order=\"C\"),\n        )\n        (\n            self.basis_change_unitaries,\n            self.diag_coulomb_mats,\n        ) = low_rank_trotter.prepare_trotter_sequence(self.time)\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                ffsim.hartree_fock_state(self.norb, self.nelec),\n                norb=self.norb,\n                nelec=self.nelec,\n            )\n            qubits = QuantumRegister(2 * norb)\n            trotter_step = AsymmetricLowRankTrotterStepJW(qubits, self.df_hamiltonian)\n            circuit = QuantumCircuit(qubits)\n            circuit.set_statevector(initial_state)\n            for instruction in simulate_trotter(\n                trotter_step,\n                self.time,\n                n_steps=self.n_steps,\n            ):\n                circuit.append(instruction)\n            circuit.save_state()\n            self.circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_fqe", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "33ab232bc3127507f450015f2896d6337eff0ed9cf44d950423f9b4827584b69", "warmup_time": -1}, "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_qiskit": {"code": "class TrotterBenchmark:\n    @skip_for_params([(16, 0.25), (16, 0.5)])\n    def time_simulate_trotter_double_factorized_qiskit(self, *_):\n        self.aer_sim.run(self.circuit).result()\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        self.time = 1.0\n        self.n_steps = 3\n        rank = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            self.norb, rank=rank, seed=rng, dtype=float\n        )\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor, two_body_tensor=two_body_tensor\n        )\n        self.df_hamiltonian = (\n            ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian(\n                mol_hamiltonian, max_vecs=rank\n            )\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        self.vec_fqe = fqe.Wavefunction([[n_alpha + n_beta, n_alpha - n_beta, norb]])\n        self.vec_fqe.set_wfn(strategy=\"hartree-fock\")\n        low_rank_trotter = LowRankTrotter(\n            oei=one_body_tensor,\n            tei=np.asarray(two_body_tensor.transpose(0, 2, 3, 1), order=\"C\"),\n        )\n        (\n            self.basis_change_unitaries,\n            self.diag_coulomb_mats,\n        ) = low_rank_trotter.prepare_trotter_sequence(self.time)\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                ffsim.hartree_fock_state(self.norb, self.nelec),\n                norb=self.norb,\n                nelec=self.nelec,\n            )\n            qubits = QuantumRegister(2 * norb)\n            trotter_step = AsymmetricLowRankTrotterStepJW(qubits, self.df_hamiltonian)\n            circuit = QuantumCircuit(qubits)\n            circuit.set_statevector(initial_state)\n            for instruction in simulate_trotter(\n                trotter_step,\n                self.time,\n                n_steps=self.n_steps,\n            ):\n                circuit.append(instruction)\n            circuit.save_state()\n            self.circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_qiskit", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "5b69ea3ee4f8de71d94602225c926b04336d03c5952f561ae6424a97176ebaeb", "warmup_time": -1}, "variational.HopGateAnsatzBenchmark.time_hop_gate_ansatz_ffsim": {"code": "class HopGateAnsatzBenchmark:\n    def time_hop_gate_ansatz_ffsim(self, *_):\n        ffsim.apply_unitary(\n            self.vec, self.operator, norb=self.norb, nelec=self.nelec, copy=False\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(norb, self.nelec)\n        interaction_pairs = list(itertools.combinations(range(norb), 2))\n        thetas = rng.uniform(-np.pi, np.pi, size=len(interaction_pairs))\n        self.operator = ffsim.HopGateAnsatzOperator(\n            norb, interaction_pairs, thetas=thetas\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "variational.HopGateAnsatzBenchmark.time_hop_gate_ansatz_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "8cf9715d7ea0ae1c363fdd5d5ef76f7e571a936309e8d2c88f164e29a902f666", "warmup_time": -1}, "variational.UCJBenchmark.time_ucj_spin_balanced_ffsim": {"code": "class UCJBenchmark:\n    def time_ucj_spin_balanced_ffsim(self, *_):\n        ffsim.apply_unitary(\n            self.vec,\n            self.ucj_op_spin_balanced,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        n_reps = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        self.ucj_op_spin_balanced = ffsim.random.random_ucj_op_spin_balanced(\n            norb, n_reps=n_reps, with_final_orbital_rotation=True, seed=rng\n        )\n        self.ucj_op_spin_unbalanced = ffsim.random.random_ucj_op_spin_unbalanced(\n            norb, n_reps=n_reps, with_final_orbital_rotation=True, seed=rng\n        )\n        self.ucj_op_spinless = ffsim.random.random_ucj_op_spinless(\n            norb, n_reps=n_reps, with_final_orbital_rotation=True, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "variational.UCJBenchmark.time_ucj_spin_balanced_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "0b8837f010da98426887e94d531ff2c2261f83fa27f71b95a3fc3004aaf72d74", "warmup_time": -1}, "variational.UCJBenchmark.time_ucj_spin_unbalanced_ffsim": {"code": "class UCJBenchmark:\n    def time_ucj_spin_unbalanced_ffsim(self, *_):\n        ffsim.apply_unitary(\n            self.vec,\n            self.ucj_op_spin_unbalanced,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        n_reps = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        self.ucj_op_spin_balanced = ffsim.random.random_ucj_op_spin_balanced(\n            norb, n_reps=n_reps, with_final_orbital_rotation=True, seed=rng\n        )\n        self.ucj_op_spin_unbalanced = ffsim.random.random_ucj_op_spin_unbalanced(\n            norb, n_reps=n_reps, with_final_orbital_rotation=True, seed=rng\n        )\n        self.ucj_op_spinless = ffsim.random.random_ucj_op_spinless(\n            norb, n_reps=n_reps, with_final_orbital_rotation=True, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "variational.UCJBenchmark.time_ucj_spin_unbalanced_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "4fa3a6613ab217a7c85b8834e39aae8b702d81dd166d23416a62d0dbb87dc6ee", "warmup_time": -1}, "variational.UCJBenchmark.time_ucj_spinless_ffsim": {"code": "class UCJBenchmark:\n    def time_ucj_spinless_ffsim(self, *_):\n        ffsim.apply_unitary(\n            self.vec,\n            self.ucj_op_spinless,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        n_reps = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        self.ucj_op_spin_balanced = ffsim.random.random_ucj_op_spin_balanced(\n            norb, n_reps=n_reps, with_final_orbital_rotation=True, seed=rng\n        )\n        self.ucj_op_spin_unbalanced = ffsim.random.random_ucj_op_spin_unbalanced(\n            norb, n_reps=n_reps, with_final_orbital_rotation=True, seed=rng\n        )\n        self.ucj_op_spinless = ffsim.random.random_ucj_op_spinless(\n            norb, n_reps=n_reps, with_final_orbital_rotation=True, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "variational.UCJBenchmark.time_ucj_spinless_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8", "12"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "e119ba99fbde41e224895ebc53f8c41ecaef7e8110c726727ab76a66b6c4ebb3", "warmup_time": -1}}, "machines": {"li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com": {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz", "machine": "li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com", "num_cpu": "8", "os": "Linux 6.5.5-200.fc38.x86_64", "ram": "16013132", "version": 1}}, "tags": {"v0.0.0-alpha": 293, "v0.0.1-alpha": 294, "v0.0.10-alpha": 633, "v0.0.11-alpha": 646, "v0.0.12": 650, "v0.0.13": 656, "v0.0.14": 692, "v0.0.15": 733, "v0.0.16": 756, "v0.0.17": 784, "v0.0.18": 838, "v0.0.19": 861, "v0.0.2-alpha": 295, "v0.0.20": 868, "v0.0.21": 877, "v0.0.22": 934, "v0.0.23": 944, "v0.0.24": 979, "v0.0.25": 1023, "v0.0.26": 1073, "v0.0.27": 1112, "v0.0.28": 1148, "v0.0.29": 1310, "v0.0.3-alpha": 328, "v0.0.30": 1326, "v0.0.31": 1362, "v0.0.32": 1384, "v0.0.33": 1399, "v0.0.34": 1426, "v0.0.35": 1609, "v0.0.36": 1700, "v0.0.4-alpha": 337, "v0.0.5-alpha": 357, "v0.0.6-alpha": 372, "v0.0.7-alpha": 397, "v0.0.8-alpha": 427, "v0.0.9-alpha": 490}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}