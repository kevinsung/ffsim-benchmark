{"project": "ffsim", "project_url": "https://github.com/qiskit-community/ffsim", "show_commit_url": "http://github.com/qiskit-community/ffsim/commit/", "hash_length": 8, "revision_to_hash": {"293": "7d8b51d1ee51b679290957edc02a450a00de8b89", "294": "6d0fbe0a170b7f6b50c5efa334e081e6ffec8134", "295": "a3f70e6a67800f3317144868056ee9ee61186911", "328": "f4705dc9a7c570a6a8bd522e7d54c9a151cd4df0", "337": "e595ca8acf92f2ad9f8a2ef65ca05c567bda84a4", "357": "e4d9c76d85bc48ab9ec62996d60f2e20f8357461", "372": "702916704a5a0841fc91d5c1457e44d85b189265", "397": "237c46fc3a1107d3aa4c9d06d187880442052142", "427": "3bd709cd803c49a9f99739e5d4236c7ec31cd7aa", "490": "80ceaca50d45c5a181e812aeff78c1b7ed9b0a44", "633": "f18b63d8a50c147179d5d14af630576b5fc8cdab", "646": "f2071476f42524e609d57469291abb50206ca491", "650": "e8c991f1840c03af713e76643f2c157245104393", "656": "b3590ab0f85de6ce3fbea2274af9a20098189c0a", "692": "f064a1e6e92a7f7de5f68cc8bcb941a9bda255f0", "733": "6349a7b338b6863f02c7658e4f52ea64ff038727", "756": "28f43bd5a2b2f369def33841d61fee4e02832d45", "784": "b8eceda4a938e816f9307cc73742f03b3ac66b6e", "838": "4dda2db86a82ba8b74b21a62d8a896ceaa3832a4", "861": "f66d3523e0a755c719ed152a91cb7320962ba7b2", "868": "067a7844a983e412cb328ac6736dd3987339b742", "877": "97461210adcf09bc994432f69a27c499359417f4", "934": "350c9fdc03f8a16e582f3f66c87d2d936f8116fd", "944": "80bd11b0d27eb1e2fd9be35ef9b0851d5647a68a", "979": "dfba40616bb34d13705733c21ca3e75df757c8ae", "1023": "e46f74e12007fe3bb8414dbc8eba96be2a21163d", "1073": "39734435d54674e19b5336512c8a16bf0c3311c1", "1112": "4144571e8134e4d8321041763122fcb1d0ba115b", "1148": "30177afbcebf6f027034b9cc15cc56cb9f0ed597", "1310": "05ad80d3dee4dd19d48aa9465eb260822da75de0", "1326": "ab6083c90f08e517caaa2188c332a054ab768678", "1327": "219cc0018e02803c856dbf8babf7f6f152eaba7e", "1331": "059d6b694488974bc186f6471518b4c30d114e69", "1332": "14ee580357387d1f1f095e50d73d7b4ce3de1fe1", "1335": "546aa342d4b2695f2114c56b188d09b73e4352b9", "1337": "71d755e9f68102aaeefa157c0f2ad22e53c9ece6", "1341": "f9f7502e85cb7274af62fe1da689a859b2c253ff", "1342": "b80e6a0a213baa7f916572d37ecbefd76a140a35", "1343": "e139f8994e90506d0cc6544dbfaef6d001797f86", "1345": "13c962f8e83b0a4a4b170ee2b7bb468834179983", "1347": "c8d5d493fdbcbc39330b0b624072110fa374393f", "1348": "52a491acdd0d225c8aaa3ae1f5ce68412d7f2d67", "1349": "73d01e158207013abbaa4d349702c983687135ba", "1350": "30e1060204370121b36ee1ee1ec6029cc39c1858", "1351": "eeb254f4a8e01e16ce651dce6b1d7ab0c7ced03e", "1352": "d581c0288cbb3d902c701fe2f715029452b622ce", "1353": "69022e866ed9ea19521a4e5242f717f160169544", "1355": "72675344b35b88d3ced0770d38c6f7b8e99ffb58", "1357": "8d90f07a583873888d4a72d45b1a5ca8c8c14003", "1358": "56575ed3ee1aa7dc6e90c96b3faeea87bd8674ef", "1359": "df41027a34e22f26b3eb790aaba50c74a67a7728", "1361": "1f8cb0bf65a482ca7b1be55f8a49e1cca8fe3e9b", "1362": "a8354b8636c409802bd572acf00f1118228b6bbe", "1364": "d7b74b69fa34244d15cc9faa1b9f659c549d4a20", "1368": "9295b5fe4e9b59ca521ea3afbb9674666b90df04", "1371": "de860a586cecd033abeb74c0e2e631ca701c986d", "1377": "b85fdc36212d43ac400367f85bf2a1ed76f72dd2", "1380": "42a65623965ab75e08b7abf47329b4e74f4a25b9", "1381": "74857e09b08e52670567dfa1991226cdc7d744ec", "1384": "e8c0bfc796d592dd9c82de61b030987b36400ac4", "1385": "68a841a86174a550e9fbb8e53e3f004a79128b25", "1390": "6e50c50ff177b1259a2ddbea6edb7671ac8e2d62", "1391": "54aed74e1720ae7a4523bec4144c9e7e108f12c1", "1394": "2264f0b0d1b82054b62dd3d4090842e99ae5c360", "1395": "f15f85ee3a5b1c727f593c054487eda10cc169d2", "1396": "049602db49eb7c99f7b587487bd10f9d1467b048", "1397": "2cd1c55a5fd5253ddb92db64ec98a4be315f45eb", "1399": "762f435f5ba2045be1f7ec305e6b488daf8caa6d", "1400": "81be0552688ee8e744fe5dbcb8e9791ae644d00a", "1405": "10f2f287906eba0e5ab1a3f30a6205e27d05185f", "1407": "f26c492267c1e904b6f6ecd6152a348aa3e48200", "1409": "d7f0d7d2f2ef88e66f6c705f3b5468109ef02ede", "1412": "8c241ffb3d270fcf830caf788600cbb5369cfa02", "1414": "9ae0e536213caaa48d5cb1023efb17351586ca3e", "1417": "77a640a3c719cbd99e7f97023ffbb77c1bfea2b5", "1418": "8c0303a84aa47c896fdb6b61178846294285da08", "1421": "3195109c7e4f377811c1b478f7a34ad857828af8", "1424": "af3eefba858b2c80daf382fbb54c814fc89e20d9", "1426": "91ff7433cb347492a098716a5af4f14624456fc6", "1427": "53a1e6c132723ea7102081b08958796785ee8e45", "1433": "048ea513e865913d0d65539345ef385b9326292b", "1435": "93fdfad02a93321408308c927f89c71d35bdaa5c", "1438": "9e95286e3c461ca69a85de61029ddd4094bc1124", "1440": "905b69389e082f189c663b7905f9a0a47807d8ef", "1443": "921d8e67064c1a9fc000108c97e502c8b445be1f", "1444": "bf568289e2dc87c0b31c5b4f0f1b5f6d65519702", "1445": "50dbc0e4201ec84f1fcc952d09e5a6d98b6ace9e", "1448": "258892d2cb1188c7f76f4f78f35f6900fddcf2a5", "1450": "80da692e8a3a7ad5628a6e09db7d114922f29466", "1453": "e7ffa0284455cec0fc3cf0fe20f5a83b0d832445", "1455": "6c5b3c1c4b25bc526dadb70d3f8b72c5b5ec8e73", "1457": "0d0aefdbeadd0e3185e36491b889213e6c99d64f", "1460": "be81e3113d7266c4ea6ed7d611fec06222ecb8da", "1466": "d3be409c8b2f8cbd40cfb26a88cf5c9908562c03", "1470": "5c43618cbf61db3991b743fdafd563f0f81f0741", "1472": "b37e93c236a828fe81d447f63365dcad65c6e561", "1473": "a12324fd0426eb062ed4373851f71d6f7ba6c351", "1474": "c585ca5ebdacca88a46d8bb4cd4c6c4b8f500467", "1477": "f256acf1ab5ac6b6fb2840249cbf7cf505bcdaa1", "1480": "ee217dd8714235d6dab1e79971f1cfa4a707e4f2", "1483": "5463be924fffb4bfe6872d933738a18581359689", "1490": "118941f170ac59006555951b930bff2b90188b06", "1492": "135be8f875c76f719ac9377e7d0dd81d8d194b26", "1496": "296f98008431e889b6bd5bf3d96d2a2f3ee1295e", "1500": "5793bb16a9bca44f2f69e543c37d821fa39fae2a", "1504": "90d87a4b25a168a8b6441b8020235734274e80e9", "1508": "4d2fb839ca6d13731e01d11ef2db7d6457019ad5", "1513": "5eb62da1e6f0164c6be068a4eea9a7ec53794b09", "1515": "61ffb8b05df888b1fadff1652d56f9ec4df21f6c", "1518": "02066481a0ecfef9f00d866625f29f38718650b9"}, "revision_to_date": {"293": 1692665093000, "294": 1692668288000, "295": 1692670808000, "328": 1693964591000, "337": 1694007721000, "357": 1695003949000, "372": 1695231818000, "397": 1695399632000, "427": 1697313998000, "490": 1697823867000, "633": 1699029978000, "646": 1699227346000, "650": 1699228584000, "656": 1699277769000, "692": 1699382827000, "733": 1700250850000, "756": 1701743240000, "784": 1702320868000, "838": 1704392793000, "861": 1704924844000, "868": 1705089971000, "877": 1705261893000, "934": 1710994045000, "944": 1711323737000, "979": 1711589804000, "1023": 1711728342000, "1073": 1712112410000, "1112": 1712669884000, "1148": 1713075885000, "1310": 1714617766000, "1326": 1714757701000, "1327": 1714757796000, "1331": 1714775463000, "1332": 1714775738000, "1335": 1714793992000, "1337": 1714821764000, "1341": 1714951078000, "1342": 1714951156000, "1343": 1715184352000, "1345": 1715184928000, "1347": 1715255234000, "1348": 1715255802000, "1349": 1715334245000, "1350": 1715334861000, "1351": 1715336223000, "1352": 1715336589000, "1353": 1715336670000, "1355": 1715386004000, "1357": 1715525024000, "1358": 1715525110000, "1359": 1715537258000, "1361": 1715564790000, "1362": 1715564877000, "1364": 1715565084000, "1368": 1715566267000, "1371": 1715648239000, "1377": 1715649226000, "1380": 1715649927000, "1381": 1715650121000, "1384": 1715650706000, "1385": 1715650766000, "1390": 1715656553000, "1391": 1715656714000, "1394": 1715658350000, "1395": 1715658376000, "1396": 1715658626000, "1397": 1715658817000, "1399": 1715659921000, "1400": 1715659995000, "1405": 1715687876000, "1407": 1715725819000, "1409": 1715743559000, "1412": 1715798551000, "1414": 1715800943000, "1417": 1715952766000, "1418": 1715952987000, "1421": 1715958991000, "1424": 1715960404000, "1426": 1715961426000, "1427": 1715961479000, "1433": 1715964438000, "1435": 1716078924000, "1438": 1716125399000, "1440": 1716128950000, "1443": 1716129739000, "1444": 1716130719000, "1445": 1716131880000, "1448": 1716134298000, "1450": 1716154574000, "1453": 1716162330000, "1455": 1716166035000, "1457": 1716166081000, "1460": 1716258887000, "1466": 1716348274000, "1470": 1716380720000, "1472": 1716382044000, "1473": 1716382693000, "1474": 1716382782000, "1477": 1716383521000, "1480": 1716426395000, "1483": 1716472296000, "1490": 1716512617000, "1492": 1716562713000, "1496": 1716654042000, "1500": 1716655317000, "1504": 1716666675000, "1508": 1716673705000, "1513": 1716679679000, "1515": 1716679922000, "1518": 1716691468000}, "params": {"arch": ["x86_64"], "cpu": ["Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz"], "machine": ["li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com"], "num_cpu": ["8"], "os": ["Linux 6.5.5-200.fc38.x86_64"], "ram": ["16013132"], "python": ["3.12"], "fqe": [""], "openfermion": [""], "qiskit-aer": [""], "env-RAYON_NUM_THREADS": ["1"], "env-OMP_NUM_THREADS": ["1"], "env-OPENBLAS_NUM_THREADS": ["1"], "env-MKL_NUM_THREADS": ["1"], "branch": ["main"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz", "machine": "li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com", "num_cpu": "8", "os": "Linux 6.5.5-200.fc38.x86_64", "ram": "16013132", "python": "3.12", "fqe": "", "openfermion": "", "qiskit-aer": "", "env-RAYON_NUM_THREADS": "1", "env-OMP_NUM_THREADS": "1", "env-OPENBLAS_NUM_THREADS": "1", "env-MKL_NUM_THREADS": "1", "branch": "main"}], "benchmarks": {"fermion_operator.FermionOperatorBenchmark.time_normal_order_ffsim": {"code": "class FermionOperatorBenchmark:\n    def time_normal_order_ffsim(self):\n        self.op_ffsim.normal_ordered()\n\n    def setup(self):\n        self.op_ffsim = random_fermion_operator(norb=50, n_terms=100, seed=4142)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)", "min_run_count": 2, "name": "fermion_operator.FermionOperatorBenchmark.time_normal_order_ffsim", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "355e202ad02eb710b9acb0b6033eb47d47c1120351f071b81d15b929666cc2cd", "warmup_time": -1}, "fermion_operator.FermionOperatorBenchmark.time_normal_order_openfermion": {"code": "class FermionOperatorBenchmark:\n    def time_normal_order_openfermion(self):\n        of.normal_ordered(self.op_openfermion)\n\n    def setup(self):\n        self.op_ffsim = random_fermion_operator(norb=50, n_terms=100, seed=4142)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)", "min_run_count": 2, "name": "fermion_operator.FermionOperatorBenchmark.time_normal_order_openfermion", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "4a631b10b71d419909df9ecdd5bbf8ff82897b5a1b1ac6119a0ca7526b7454d1", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_diag_coulomb_evolution": {"code": "class GatesBenchmark:\n    def time_apply_diag_coulomb_evolution(self, *_):\n        ffsim.apply_diag_coulomb_evolution(\n            self.vec,\n            self.diag_coulomb_mat,\n            time=1.0,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_diag_coulomb_evolution", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "eaa8c6df5a97e2c399dcfad06a9c671129b70eb6f8af4ae3aa3521b153d7da42", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_givens_rotation": {"code": "class GatesBenchmark:\n    def time_apply_givens_rotation(self, *_):\n        ffsim.apply_givens_rotation(\n            self.vec,\n            theta=1.0,\n            target_orbs=(0, 2),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_givens_rotation", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "82d9aded8de49abe8750cdcea5386e7a48b0c7bae71d5d73508aa82b984c3b9a", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_interaction": {"code": "class GatesBenchmark:\n    def time_apply_num_interaction(self, *_):\n        ffsim.apply_num_interaction(\n            self.vec,\n            theta=1.0,\n            target_orb=1,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_interaction", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "770bf80ba2baef7f2681d031af4b4c3596e56762d5b1f48270e3ea0e9155b63a", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_num_interaction": {"code": "class GatesBenchmark:\n    def time_apply_num_num_interaction(self, *_):\n        ffsim.apply_num_num_interaction(\n            self.vec,\n            theta=1.0,\n            target_orbs=(0, 1),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_num_interaction", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "57ea086945bc3739d213b0efc7e09f45318cfbb5b1149eedb09f17ed48577b4a", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_op_prod_interaction": {"code": "class GatesBenchmark:\n    def time_apply_num_op_prod_interaction(self, *_):\n        ffsim.apply_num_op_prod_interaction(\n            self.vec,\n            theta=1.0,\n            target_orbs=([1], [0]),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_op_prod_interaction", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "d812cd7515c400ca454f0dd67566e1062542942e4cfdce0bef4072a9756a0a71", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_op_sum_evolution": {"code": "class GatesBenchmark:\n    def time_apply_num_op_sum_evolution(self, *_):\n        ffsim.apply_num_op_sum_evolution(\n            self.vec,\n            self.orbital_energies,\n            time=1.0,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_op_sum_evolution", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "63fea3b51c8533f1e9d4757844301f8aecd1b68cfa620eb389c60fd749ae0bfb", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_tunneling_interaction": {"code": "class GatesBenchmark:\n    def time_apply_tunneling_interaction(self, *_):\n        ffsim.apply_tunneling_interaction(\n            self.vec,\n            theta=1.0,\n            target_orbs=(0, 2),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_tunneling_interaction", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "31094a9db87039f5042610471d78c963312333bfe7117e7f0c7e3a7263895148", "warmup_time": -1}, "linear_operator.LinearOperatorBenchmark.time_molecular_hamiltonian": {"code": "class LinearOperatorBenchmark:\n    def time_molecular_hamiltonian(self, *_):\n        _ = self.mol_hamiltonian_linop @ self.vec\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            norb, seed=rng, dtype=float\n        )\n        constant = rng.standard_normal()\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor,\n            two_body_tensor=two_body_tensor,\n            constant=constant,\n        )\n        self.mol_hamiltonian_linop = ffsim.linear_operator(\n            mol_hamiltonian, norb=norb, nelec=self.nelec\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "linear_operator.LinearOperatorBenchmark.time_molecular_hamiltonian", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "0ba7cedc12d90578f47ce2255000d9b446a66dd150a988a7ad6df853caa00094", "warmup_time": -1}, "operator_action.OperatorActionBenchmark.time_ffsim": {"code": "class OperatorActionBenchmark:\n    def time_ffsim(self, *_):\n        _ = self.linop_ffsim @ self.vec_ffsim\n\n    def setup(self, norb: int, filling_fraction: float):\n        rng = np.random.default_rng(5853)\n    \n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        self.vec_ffsim = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec)\n        )\n        self.wfn_fqe = ffsim_vec_to_fqe_wfn(\n            self.vec_ffsim, norb=self.norb, nelec=self.nelec\n        )\n        self.op_ffsim = random_fermion_hamiltonian(norb=norb, n_terms=50, seed=rng)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)\n        self.linop_ffsim = ffsim.linear_operator(\n            self.op_ffsim, norb=self.norb, nelec=self.nelec\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "operator_action.OperatorActionBenchmark.time_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "dae353a860257ffa79e2eabbd6d072f3d36756729406c4c06ca4a26e08d18993", "warmup_time": -1}, "operator_action.OperatorActionBenchmark.time_openfermion": {"code": "class OperatorActionBenchmark:\n    def time_openfermion(self, *_):\n        _ = self.wfn_fqe.apply(self.op_openfermion)\n\n    def setup(self, norb: int, filling_fraction: float):\n        rng = np.random.default_rng(5853)\n    \n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        self.vec_ffsim = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec)\n        )\n        self.wfn_fqe = ffsim_vec_to_fqe_wfn(\n            self.vec_ffsim, norb=self.norb, nelec=self.nelec\n        )\n        self.op_ffsim = random_fermion_hamiltonian(norb=norb, n_terms=50, seed=rng)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)\n        self.linop_ffsim = ffsim.linear_operator(\n            self.op_ffsim, norb=self.norb, nelec=self.nelec\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "operator_action.OperatorActionBenchmark.time_openfermion", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "e544b78b28afd79b1f92b30711c0c88d169a672d3073e7a814a93171590e17d0", "warmup_time": -1}, "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation": {"code": "class OrbitalRotationBenchmark:\n    def time_apply_orbital_rotation(self, *_):\n        ffsim.apply_orbital_rotation(\n            self.vec,\n            self.orbital_rotation,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n            validate=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.orbital_rotation = ffsim.random.random_unitary(norb, seed=rng)\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            register = QuantumRegister(2 * norb)\n            circuit = QuantumCircuit(register)\n            circuit.set_statevector(initial_state)\n            circuit.append(\n                ffsim.qiskit.OrbitalRotationJW(norb, self.orbital_rotation), register\n            )\n            circuit.save_state()\n            self.orbital_rotation_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "8a1bed4755191857a2eb2eb2942a977885aed3991a279e34b459520e9ae1403c", "warmup_time": -1}, "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_fqe": {"code": "class OrbitalRotationBenchmark:\n    @skip_for_params([(16, 0.5)])\n    def time_apply_orbital_rotation_fqe(self, *_):\n        evolve_fqe_givens(self.vec_fqe, self.orbital_rotation)\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.orbital_rotation = ffsim.random.random_unitary(norb, seed=rng)\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            register = QuantumRegister(2 * norb)\n            circuit = QuantumCircuit(register)\n            circuit.set_statevector(initial_state)\n            circuit.append(\n                ffsim.qiskit.OrbitalRotationJW(norb, self.orbital_rotation), register\n            )\n            circuit.save_state()\n            self.orbital_rotation_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_fqe", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "642e6e64c154381c95398aee5aa8f054e7cdacc40f0b66c3057ba0a5df20b09e", "warmup_time": -1}, "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_qiskit": {"code": "class OrbitalRotationBenchmark:\n    @skip_for_params([(16, 0.25), (16, 0.5)])\n    def time_apply_orbital_rotation_qiskit(self, *_):\n        self.aer_sim.run(self.orbital_rotation_circuit).result()\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.orbital_rotation = ffsim.random.random_unitary(norb, seed=rng)\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            register = QuantumRegister(2 * norb)\n            circuit = QuantumCircuit(register)\n            circuit.set_statevector(initial_state)\n            circuit.append(\n                ffsim.qiskit.OrbitalRotationJW(norb, self.orbital_rotation), register\n            )\n            circuit.save_state()\n            self.orbital_rotation_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_qiskit", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "310cf637fcb9e358b371586b9be785f37c3ec1bd916dad76611866b1c429cd1d", "warmup_time": -1}, "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution": {"code": "class QuadHamEvoBenchmark:\n    def time_quad_ham_evolution(self, *_):\n        ffsim.apply_num_op_sum_evolution(\n            self.vec,\n            self.orbital_energies,\n            time=1.0,\n            norb=self.norb,\n            nelec=self.nelec,\n            orbital_rotation=self.orbital_rotation,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        self.fqe_ham = RestrictedHamiltonian((self.one_body_tensor,))\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            circuit = num_op_sum_evo_circuit(\n                self.orbital_energies,\n                initial_state,\n                1.0,\n                norb=norb,\n                orbital_rotation=self.orbital_rotation,\n            )\n            self.quad_ham_evo_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "9a00e385e4da68c21685dfcc59692ef75a6baee2fd123e1334c52ea4a2b7de85", "warmup_time": -1}, "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_fqe": {"code": "class QuadHamEvoBenchmark:\n    def time_quad_ham_evolution_fqe(self, *_):\n        self.vec_fqe.time_evolve(1.0, self.fqe_ham)\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        self.fqe_ham = RestrictedHamiltonian((self.one_body_tensor,))\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            circuit = num_op_sum_evo_circuit(\n                self.orbital_energies,\n                initial_state,\n                1.0,\n                norb=norb,\n                orbital_rotation=self.orbital_rotation,\n            )\n            self.quad_ham_evo_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_fqe", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "28ef76daa318213970c7ab4ae0eac7220dc9009c190fb07e2d70a6e38d95474d", "warmup_time": -1}, "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_qiskit": {"code": "class QuadHamEvoBenchmark:\n    @skip_for_params([(16, 0.25), (16, 0.5)])\n    def time_quad_ham_evolution_qiskit(self, *_):\n        self.aer_sim.run(self.quad_ham_evo_circuit).result()\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        self.fqe_ham = RestrictedHamiltonian((self.one_body_tensor,))\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            circuit = num_op_sum_evo_circuit(\n                self.orbital_energies,\n                initial_state,\n                1.0,\n                norb=norb,\n                orbital_rotation=self.orbital_rotation,\n            )\n            self.quad_ham_evo_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_qiskit", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "c57ac82719d2a2f7c30ebff90dd283586b04b232cc2d7f205ed7549045000d0c", "warmup_time": -1}, "rust.RustBenchmark.time_apply_givens_rotation_in_place_python": {"code": "class RustBenchmark:\n    def time_apply_givens_rotation_in_place_python(self, *_):\n        apply_givens_rotation_in_place_slow(\n            self.vec_as_mat,\n            c=0.5,\n            s=(1j) ** 0.5 * np.sqrt(0.75),\n            slice1=self.slice1,\n            slice2=self.slice2,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        rng = np.random.default_rng()\n    \n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_as_mat = self.vec.reshape((dim_a, dim_b))\n    \n        indices = _zero_one_subspace_indices(self.norb, self.nelec[0], (1, 2))\n        self.slice1 = indices[: len(indices) // 2]\n        self.slice2 = indices[len(indices) // 2 :]", "min_run_count": 2, "name": "rust.RustBenchmark.time_apply_givens_rotation_in_place_python", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "e58784ec9943245b27f40334141920299cc473f378eb406bd27d7b2783850522", "warmup_time": -1}, "rust.RustBenchmark.time_apply_givens_rotation_in_place_rust": {"code": "class RustBenchmark:\n    def time_apply_givens_rotation_in_place_rust(self, *_):\n        apply_givens_rotation_in_place(\n            self.vec_as_mat,\n            c=0.5,\n            s=(1j) ** 0.5 * np.sqrt(0.75),\n            slice1=self.slice1,\n            slice2=self.slice2,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        rng = np.random.default_rng()\n    \n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_as_mat = self.vec.reshape((dim_a, dim_b))\n    \n        indices = _zero_one_subspace_indices(self.norb, self.nelec[0], (1, 2))\n        self.slice1 = indices[: len(indices) // 2]\n        self.slice2 = indices[len(indices) // 2 :]", "min_run_count": 2, "name": "rust.RustBenchmark.time_apply_givens_rotation_in_place_rust", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "0b7e6fb3fe123033a9689da7304948f1db67433c4ed5a67402e9194cfbbce141", "warmup_time": -1}, "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized": {"code": "class TrotterBenchmark:\n    def time_simulate_trotter_double_factorized(self, *_):\n        ffsim.simulate_trotter_double_factorized(\n            self.vec,\n            self.df_hamiltonian,\n            self.time,\n            norb=self.norb,\n            nelec=self.nelec,\n            n_steps=self.n_steps,\n            order=0,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        self.time = 1.0\n        self.n_steps = 3\n        rank = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            self.norb, rank=rank, seed=rng, dtype=float\n        )\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor, two_body_tensor=two_body_tensor\n        )\n        self.df_hamiltonian = (\n            ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian(\n                mol_hamiltonian, max_vecs=rank\n            )\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        self.vec_fqe = fqe.Wavefunction([[n_alpha + n_beta, n_alpha - n_beta, norb]])\n        self.vec_fqe.set_wfn(strategy=\"hartree-fock\")\n        low_rank_trotter = LowRankTrotter(\n            oei=one_body_tensor,\n            tei=np.asarray(two_body_tensor.transpose(0, 2, 3, 1), order=\"C\"),\n        )\n        (\n            self.basis_change_unitaries,\n            self.diag_coulomb_mats,\n        ) = low_rank_trotter.prepare_trotter_sequence(self.time)\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                ffsim.hartree_fock_state(self.norb, self.nelec),\n                norb=self.norb,\n                nelec=self.nelec,\n            )\n            qubits = QuantumRegister(2 * norb)\n            trotter_step = AsymmetricLowRankTrotterStepJW(qubits, self.df_hamiltonian)\n            circuit = QuantumCircuit(qubits)\n            circuit.set_statevector(initial_state)\n            for instruction in simulate_trotter(\n                trotter_step,\n                self.time,\n                n_steps=self.n_steps,\n            ):\n                circuit.append(instruction)\n            circuit.save_state()\n            self.circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "8b63af3333d435e46271b0d451b2c60222fbae151e875c579d394ab955d320a3", "warmup_time": -1}, "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_fqe": {"code": "class TrotterBenchmark:\n    @skip_for_params([(16, 0.5)])\n    def time_simulate_trotter_double_factorized_fqe(self, *_):\n        simulate_trotter_double_factorized_fqe(\n            self.vec_fqe,\n            time=self.time,\n            n_steps=self.n_steps,\n            basis_change_unitaries=self.basis_change_unitaries,\n            diag_coulomb_mats=self.diag_coulomb_mats,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        self.time = 1.0\n        self.n_steps = 3\n        rank = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            self.norb, rank=rank, seed=rng, dtype=float\n        )\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor, two_body_tensor=two_body_tensor\n        )\n        self.df_hamiltonian = (\n            ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian(\n                mol_hamiltonian, max_vecs=rank\n            )\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        self.vec_fqe = fqe.Wavefunction([[n_alpha + n_beta, n_alpha - n_beta, norb]])\n        self.vec_fqe.set_wfn(strategy=\"hartree-fock\")\n        low_rank_trotter = LowRankTrotter(\n            oei=one_body_tensor,\n            tei=np.asarray(two_body_tensor.transpose(0, 2, 3, 1), order=\"C\"),\n        )\n        (\n            self.basis_change_unitaries,\n            self.diag_coulomb_mats,\n        ) = low_rank_trotter.prepare_trotter_sequence(self.time)\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                ffsim.hartree_fock_state(self.norb, self.nelec),\n                norb=self.norb,\n                nelec=self.nelec,\n            )\n            qubits = QuantumRegister(2 * norb)\n            trotter_step = AsymmetricLowRankTrotterStepJW(qubits, self.df_hamiltonian)\n            circuit = QuantumCircuit(qubits)\n            circuit.set_statevector(initial_state)\n            for instruction in simulate_trotter(\n                trotter_step,\n                self.time,\n                n_steps=self.n_steps,\n            ):\n                circuit.append(instruction)\n            circuit.save_state()\n            self.circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_fqe", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "33ab232bc3127507f450015f2896d6337eff0ed9cf44d950423f9b4827584b69", "warmup_time": -1}, "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_qiskit": {"code": "class TrotterBenchmark:\n    @skip_for_params([(16, 0.25), (16, 0.5)])\n    def time_simulate_trotter_double_factorized_qiskit(self, *_):\n        self.aer_sim.run(self.circuit).result()\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        self.time = 1.0\n        self.n_steps = 3\n        rank = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            self.norb, rank=rank, seed=rng, dtype=float\n        )\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor, two_body_tensor=two_body_tensor\n        )\n        self.df_hamiltonian = (\n            ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian(\n                mol_hamiltonian, max_vecs=rank\n            )\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        self.vec_fqe = fqe.Wavefunction([[n_alpha + n_beta, n_alpha - n_beta, norb]])\n        self.vec_fqe.set_wfn(strategy=\"hartree-fock\")\n        low_rank_trotter = LowRankTrotter(\n            oei=one_body_tensor,\n            tei=np.asarray(two_body_tensor.transpose(0, 2, 3, 1), order=\"C\"),\n        )\n        (\n            self.basis_change_unitaries,\n            self.diag_coulomb_mats,\n        ) = low_rank_trotter.prepare_trotter_sequence(self.time)\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                ffsim.hartree_fock_state(self.norb, self.nelec),\n                norb=self.norb,\n                nelec=self.nelec,\n            )\n            qubits = QuantumRegister(2 * norb)\n            trotter_step = AsymmetricLowRankTrotterStepJW(qubits, self.df_hamiltonian)\n            circuit = QuantumCircuit(qubits)\n            circuit.set_statevector(initial_state)\n            for instruction in simulate_trotter(\n                trotter_step,\n                self.time,\n                n_steps=self.n_steps,\n            ):\n                circuit.append(instruction)\n            circuit.save_state()\n            self.circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_qiskit", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "5b69ea3ee4f8de71d94602225c926b04336d03c5952f561ae6424a97176ebaeb", "warmup_time": -1}, "variational.HopGateAnsatzBenchmark.time_hop_gate_ansatz": {"code": "class HopGateAnsatzBenchmark:\n    def time_hop_gate_ansatz(self, *_):\n        ffsim.apply_unitary(\n            self.vec, self.operator, norb=self.norb, nelec=self.nelec, copy=False\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(norb, self.nelec)\n        interaction_pairs = list(itertools.combinations(range(norb), 2))\n        thetas = rng.uniform(-np.pi, np.pi, size=len(interaction_pairs))\n        self.operator = ffsim.HopGateAnsatzOperator(\n            norb, interaction_pairs, thetas=thetas\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "variational.HopGateAnsatzBenchmark.time_hop_gate_ansatz", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "caa743469d9cce14a658b02b7d99eb96790891ee1613eef779dca90857a9a553", "warmup_time": -1}, "variational.UCJBenchmark.time_ucj": {"code": "class UCJBenchmark:\n    def time_ucj(self, *_):\n        ffsim.apply_unitary(\n            self.vec, self.operator, norb=self.norb, nelec=self.nelec, copy=False\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        n_reps = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        t2 = ffsim.random.random_t2_amplitudes(self.norb, nocc, seed=rng, dtype=float)\n        self.operator = ffsim.UCJOperator.from_t_amplitudes(t2, n_reps=n_reps)\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "variational.UCJBenchmark.time_ucj", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "5cb72dfb3cfbf5d0857558fb2e7cec1fb3695a105864bba5748f685df32a549e", "warmup_time": -1}}, "machines": {"li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com": {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz", "machine": "li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com", "num_cpu": "8", "os": "Linux 6.5.5-200.fc38.x86_64", "ram": "16013132", "version": 1}}, "tags": {"v0.0.0-alpha": 293, "v0.0.1-alpha": 294, "v0.0.10-alpha": 633, "v0.0.11-alpha": 646, "v0.0.12": 650, "v0.0.13": 656, "v0.0.14": 692, "v0.0.15": 733, "v0.0.16": 756, "v0.0.17": 784, "v0.0.18": 838, "v0.0.19": 861, "v0.0.2-alpha": 295, "v0.0.20": 868, "v0.0.21": 877, "v0.0.22": 934, "v0.0.23": 944, "v0.0.24": 979, "v0.0.25": 1023, "v0.0.26": 1073, "v0.0.27": 1112, "v0.0.28": 1148, "v0.0.29": 1310, "v0.0.3-alpha": 328, "v0.0.30": 1326, "v0.0.31": 1362, "v0.0.32": 1384, "v0.0.33": 1399, "v0.0.34": 1426, "v0.0.4-alpha": 337, "v0.0.5-alpha": 357, "v0.0.6-alpha": 372, "v0.0.7-alpha": 397, "v0.0.8-alpha": 427, "v0.0.9-alpha": 490}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}