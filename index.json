{"project": "ffsim", "project_url": "https://github.com/qiskit-community/ffsim", "show_commit_url": "http://github.com/qiskit-community/ffsim/commit/", "hash_length": 8, "revision_to_hash": {"293": "7d8b51d1ee51b679290957edc02a450a00de8b89", "294": "6d0fbe0a170b7f6b50c5efa334e081e6ffec8134", "295": "a3f70e6a67800f3317144868056ee9ee61186911", "328": "f4705dc9a7c570a6a8bd522e7d54c9a151cd4df0", "337": "e595ca8acf92f2ad9f8a2ef65ca05c567bda84a4", "357": "e4d9c76d85bc48ab9ec62996d60f2e20f8357461", "372": "702916704a5a0841fc91d5c1457e44d85b189265", "397": "237c46fc3a1107d3aa4c9d06d187880442052142", "427": "3bd709cd803c49a9f99739e5d4236c7ec31cd7aa", "490": "80ceaca50d45c5a181e812aeff78c1b7ed9b0a44", "633": "f18b63d8a50c147179d5d14af630576b5fc8cdab", "646": "f2071476f42524e609d57469291abb50206ca491", "650": "e8c991f1840c03af713e76643f2c157245104393", "656": "b3590ab0f85de6ce3fbea2274af9a20098189c0a", "692": "f064a1e6e92a7f7de5f68cc8bcb941a9bda255f0", "733": "6349a7b338b6863f02c7658e4f52ea64ff038727", "756": "28f43bd5a2b2f369def33841d61fee4e02832d45", "784": "b8eceda4a938e816f9307cc73742f03b3ac66b6e", "838": "4dda2db86a82ba8b74b21a62d8a896ceaa3832a4", "861": "f66d3523e0a755c719ed152a91cb7320962ba7b2", "868": "067a7844a983e412cb328ac6736dd3987339b742", "877": "97461210adcf09bc994432f69a27c499359417f4", "934": "350c9fdc03f8a16e582f3f66c87d2d936f8116fd", "944": "80bd11b0d27eb1e2fd9be35ef9b0851d5647a68a", "979": "dfba40616bb34d13705733c21ca3e75df757c8ae", "1023": "e46f74e12007fe3bb8414dbc8eba96be2a21163d", "1073": "39734435d54674e19b5336512c8a16bf0c3311c1", "1112": "4144571e8134e4d8321041763122fcb1d0ba115b", "1122": "ad040a3d34843030e963d95a8c961cdb1df61b0d", "1135": "5f2f0a97da8a3edc769287fac9280d5547bf70bb", "1148": "30177afbcebf6f027034b9cc15cc56cb9f0ed597", "1155": "3401ba9b1028ae649b3e636e5c7be39f1e028da3", "1157": "5ed19055130ee20659a6e432409921fc8d03abb5", "1304": "05ad80d3dee4dd19d48aa9465eb260822da75de0", "1320": "ab6083c90f08e517caaa2188c332a054ab768678", "1356": "a8354b8636c409802bd572acf00f1118228b6bbe", "1378": "e8c0bfc796d592dd9c82de61b030987b36400ac4", "1393": "762f435f5ba2045be1f7ec305e6b488daf8caa6d", "1420": "91ff7433cb347492a098716a5af4f14624456fc6", "1485": "135be8f875c76f719ac9377e7d0dd81d8d194b26", "1489": "296f98008431e889b6bd5bf3d96d2a2f3ee1295e", "1493": "5793bb16a9bca44f2f69e543c37d821fa39fae2a", "1495": "90d87a4b25a168a8b6441b8020235734274e80e9"}, "revision_to_date": {"293": 1692665093000, "294": 1692668288000, "295": 1692670808000, "328": 1693964591000, "337": 1694007721000, "357": 1695003949000, "372": 1695231818000, "397": 1695399632000, "427": 1697313998000, "490": 1697823867000, "633": 1699029978000, "646": 1699227346000, "650": 1699228584000, "656": 1699277769000, "692": 1699382827000, "733": 1700250850000, "756": 1701743240000, "784": 1702320868000, "838": 1704392793000, "861": 1704924844000, "868": 1705089971000, "877": 1705261893000, "934": 1710994045000, "944": 1711323737000, "979": 1711589804000, "1023": 1711728342000, "1073": 1712112410000, "1112": 1712669884000, "1122": 1712727799000, "1135": 1712993572000, "1148": 1713075885000, "1155": 1713148941000, "1157": 1713365730000, "1304": 1714617766000, "1320": 1714757701000, "1356": 1715564877000, "1378": 1715650706000, "1393": 1715659921000, "1420": 1715961426000, "1485": 1716562713000, "1489": 1716654042000, "1493": 1716655317000, "1495": 1716666675000}, "params": {"arch": ["x86_64"], "cpu": ["Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz"], "machine": ["li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com"], "num_cpu": ["8"], "os": ["Linux 6.5.5-200.fc38.x86_64"], "ram": ["16013132"], "python": ["3.10"], "fqe": [""], "openfermion": [""], "qiskit-aer": [""], "env-RAYON_NUM_THREADS": ["1"], "env-OMP_NUM_THREADS": ["1"], "env-OPENBLAS_NUM_THREADS": ["1"], "env-MKL_NUM_THREADS": ["1"], "branch": ["main"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz", "machine": "li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com", "num_cpu": "8", "os": "Linux 6.5.5-200.fc38.x86_64", "ram": "16013132", "python": "3.10", "fqe": "", "openfermion": "", "qiskit-aer": "", "env-RAYON_NUM_THREADS": "1", "env-OMP_NUM_THREADS": "1", "env-OPENBLAS_NUM_THREADS": "1", "env-MKL_NUM_THREADS": "1", "branch": "main"}], "benchmarks": {"fermion_operator.FermionOperatorBenchmark.time_normal_order_ffsim": {"code": "class FermionOperatorBenchmark:\n    def time_normal_order_ffsim(self):\n        self.op_ffsim.normal_ordered()\n\n    def setup(self):\n        self.op_ffsim = random_fermion_operator(norb=50, n_terms=100, seed=4142)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)", "min_run_count": 2, "name": "fermion_operator.FermionOperatorBenchmark.time_normal_order_ffsim", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "355e202ad02eb710b9acb0b6033eb47d47c1120351f071b81d15b929666cc2cd", "warmup_time": -1}, "fermion_operator.FermionOperatorBenchmark.time_normal_order_openfermion": {"code": "class FermionOperatorBenchmark:\n    def time_normal_order_openfermion(self):\n        of.normal_ordered(self.op_openfermion)\n\n    def setup(self):\n        self.op_ffsim = random_fermion_operator(norb=50, n_terms=100, seed=4142)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)", "min_run_count": 2, "name": "fermion_operator.FermionOperatorBenchmark.time_normal_order_openfermion", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "4a631b10b71d419909df9ecdd5bbf8ff82897b5a1b1ac6119a0ca7526b7454d1", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_diag_coulomb_evolution": {"code": "class GatesBenchmark:\n    def time_apply_diag_coulomb_evolution(self, *_):\n        ffsim.apply_diag_coulomb_evolution(\n            self.vec,\n            self.diag_coulomb_mat,\n            time=1.0,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_diag_coulomb_evolution", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "eaa8c6df5a97e2c399dcfad06a9c671129b70eb6f8af4ae3aa3521b153d7da42", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_givens_rotation": {"code": "class GatesBenchmark:\n    def time_apply_givens_rotation(self, *_):\n        ffsim.apply_givens_rotation(\n            self.vec,\n            theta=1.0,\n            target_orbs=(0, 2),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_givens_rotation", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "82d9aded8de49abe8750cdcea5386e7a48b0c7bae71d5d73508aa82b984c3b9a", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_interaction": {"code": "class GatesBenchmark:\n    def time_apply_num_interaction(self, *_):\n        ffsim.apply_num_interaction(\n            self.vec,\n            theta=1.0,\n            target_orb=1,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_interaction", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "770bf80ba2baef7f2681d031af4b4c3596e56762d5b1f48270e3ea0e9155b63a", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_num_interaction": {"code": "class GatesBenchmark:\n    def time_apply_num_num_interaction(self, *_):\n        ffsim.apply_num_num_interaction(\n            self.vec,\n            theta=1.0,\n            target_orbs=(0, 1),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_num_interaction", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "57ea086945bc3739d213b0efc7e09f45318cfbb5b1149eedb09f17ed48577b4a", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_op_prod_interaction": {"code": "class GatesBenchmark:\n    def time_apply_num_op_prod_interaction(self, *_):\n        ffsim.apply_num_op_prod_interaction(\n            self.vec,\n            theta=1.0,\n            target_orbs=([1], [0]),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_op_prod_interaction", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "d812cd7515c400ca454f0dd67566e1062542942e4cfdce0bef4072a9756a0a71", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_num_op_sum_evolution": {"code": "class GatesBenchmark:\n    def time_apply_num_op_sum_evolution(self, *_):\n        ffsim.apply_num_op_sum_evolution(\n            self.vec,\n            self.orbital_energies,\n            time=1.0,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_num_op_sum_evolution", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "63fea3b51c8533f1e9d4757844301f8aecd1b68cfa620eb389c60fd749ae0bfb", "warmup_time": -1}, "gates.GatesBenchmark.time_apply_tunneling_interaction": {"code": "class GatesBenchmark:\n    def time_apply_tunneling_interaction(self, *_):\n        ffsim.apply_tunneling_interaction(\n            self.vec,\n            theta=1.0,\n            target_orbs=(0, 2),\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n        self.diag_coulomb_mat = ffsim.random.random_real_symmetric_matrix(\n            self.norb, seed=rng\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "gates.GatesBenchmark.time_apply_tunneling_interaction", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "31094a9db87039f5042610471d78c963312333bfe7117e7f0c7e3a7263895148", "warmup_time": -1}, "linear_operator.LinearOperatorBenchmark.time_molecular_hamiltonian": {"code": "class LinearOperatorBenchmark:\n    def time_molecular_hamiltonian(self, *_):\n        _ = self.mol_hamiltonian_linop @ self.vec\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            norb, seed=rng, dtype=float\n        )\n        constant = rng.standard_normal()\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor,\n            two_body_tensor=two_body_tensor,\n            constant=constant,\n        )\n        self.mol_hamiltonian_linop = ffsim.linear_operator(\n            mol_hamiltonian, norb=norb, nelec=self.nelec\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "linear_operator.LinearOperatorBenchmark.time_molecular_hamiltonian", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "0ba7cedc12d90578f47ce2255000d9b446a66dd150a988a7ad6df853caa00094", "warmup_time": -1}, "operator_action.OperatorActionBenchmark.time_ffsim": {"code": "class OperatorActionBenchmark:\n    def time_ffsim(self, *_):\n        _ = self.linop_ffsim @ self.vec_ffsim\n\n    def setup(self, norb: int, filling_fraction: float):\n        rng = np.random.default_rng(5853)\n    \n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        self.vec_ffsim = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec)\n        )\n        self.wfn_fqe = ffsim_vec_to_fqe_wfn(\n            self.vec_ffsim, norb=self.norb, nelec=self.nelec\n        )\n        self.op_ffsim = random_fermion_hamiltonian(norb=norb, n_terms=50, seed=rng)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)\n        self.linop_ffsim = ffsim.linear_operator(\n            self.op_ffsim, norb=self.norb, nelec=self.nelec\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "operator_action.OperatorActionBenchmark.time_ffsim", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "dae353a860257ffa79e2eabbd6d072f3d36756729406c4c06ca4a26e08d18993", "warmup_time": -1}, "operator_action.OperatorActionBenchmark.time_openfermion": {"code": "class OperatorActionBenchmark:\n    def time_openfermion(self, *_):\n        _ = self.wfn_fqe.apply(self.op_openfermion)\n\n    def setup(self, norb: int, filling_fraction: float):\n        rng = np.random.default_rng(5853)\n    \n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        self.vec_ffsim = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec)\n        )\n        self.wfn_fqe = ffsim_vec_to_fqe_wfn(\n            self.vec_ffsim, norb=self.norb, nelec=self.nelec\n        )\n        self.op_ffsim = random_fermion_hamiltonian(norb=norb, n_terms=50, seed=rng)\n        self.op_openfermion = ffsim_op_to_openfermion_op(self.op_ffsim)\n        self.linop_ffsim = ffsim.linear_operator(\n            self.op_ffsim, norb=self.norb, nelec=self.nelec\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "operator_action.OperatorActionBenchmark.time_openfermion", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "e544b78b28afd79b1f92b30711c0c88d169a672d3073e7a814a93171590e17d0", "warmup_time": -1}, "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation": {"code": "class OrbitalRotationBenchmark:\n    def time_apply_orbital_rotation(self, *_):\n        ffsim.apply_orbital_rotation(\n            self.vec,\n            self.orbital_rotation,\n            norb=self.norb,\n            nelec=self.nelec,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.orbital_rotation = ffsim.random.random_unitary(norb, seed=rng)\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            register = QuantumRegister(2 * norb)\n            circuit = QuantumCircuit(register)\n            circuit.set_statevector(initial_state)\n            circuit.append(\n                ffsim.qiskit.OrbitalRotationJW(norb, self.orbital_rotation), register\n            )\n            circuit.save_state()\n            self.orbital_rotation_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "3796310272badaf863e8df849c29180447e1a5a39d1bd7f765da22e9681d88a4", "warmup_time": -1}, "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_fqe": {"code": "class OrbitalRotationBenchmark:\n    @skip_for_params([(16, 0.5)])\n    def time_apply_orbital_rotation_fqe(self, *_):\n        evolve_fqe_givens(self.vec_fqe, self.orbital_rotation)\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.orbital_rotation = ffsim.random.random_unitary(norb, seed=rng)\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            register = QuantumRegister(2 * norb)\n            circuit = QuantumCircuit(register)\n            circuit.set_statevector(initial_state)\n            circuit.append(\n                ffsim.qiskit.OrbitalRotationJW(norb, self.orbital_rotation), register\n            )\n            circuit.save_state()\n            self.orbital_rotation_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_fqe", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "642e6e64c154381c95398aee5aa8f054e7cdacc40f0b66c3057ba0a5df20b09e", "warmup_time": -1}, "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_qiskit": {"code": "class OrbitalRotationBenchmark:\n    @skip_for_params([(16, 0.25), (16, 0.5)])\n    def time_apply_orbital_rotation_qiskit(self, *_):\n        self.aer_sim.run(self.orbital_rotation_circuit).result()\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.orbital_rotation = ffsim.random.random_unitary(norb, seed=rng)\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            register = QuantumRegister(2 * norb)\n            circuit = QuantumCircuit(register)\n            circuit.set_statevector(initial_state)\n            circuit.append(\n                ffsim.qiskit.OrbitalRotationJW(norb, self.orbital_rotation), register\n            )\n            circuit.save_state()\n            self.orbital_rotation_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "orbital_rotation.OrbitalRotationBenchmark.time_apply_orbital_rotation_qiskit", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "310cf637fcb9e358b371586b9be785f37c3ec1bd916dad76611866b1c429cd1d", "warmup_time": -1}, "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution": {"code": "class QuadHamEvoBenchmark:\n    def time_quad_ham_evolution(self, *_):\n        ffsim.apply_num_op_sum_evolution(\n            self.vec,\n            self.orbital_energies,\n            time=1.0,\n            norb=self.norb,\n            nelec=self.nelec,\n            orbital_rotation=self.orbital_rotation,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        self.fqe_ham = RestrictedHamiltonian((self.one_body_tensor,))\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            circuit = num_op_sum_evo_circuit(\n                self.orbital_energies,\n                initial_state,\n                1.0,\n                norb=norb,\n                orbital_rotation=self.orbital_rotation,\n            )\n            self.quad_ham_evo_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "9a00e385e4da68c21685dfcc59692ef75a6baee2fd123e1334c52ea4a2b7de85", "warmup_time": -1}, "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_fqe": {"code": "class QuadHamEvoBenchmark:\n    def time_quad_ham_evolution_fqe(self, *_):\n        self.vec_fqe.time_evolve(1.0, self.fqe_ham)\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        self.fqe_ham = RestrictedHamiltonian((self.one_body_tensor,))\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            circuit = num_op_sum_evo_circuit(\n                self.orbital_energies,\n                initial_state,\n                1.0,\n                norb=norb,\n                orbital_rotation=self.orbital_rotation,\n            )\n            self.quad_ham_evo_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_fqe", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "28ef76daa318213970c7ab4ae0eac7220dc9009c190fb07e2d70a6e38d95474d", "warmup_time": -1}, "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_qiskit": {"code": "class QuadHamEvoBenchmark:\n    @skip_for_params([(16, 0.25), (16, 0.5)])\n    def time_quad_ham_evolution_qiskit(self, *_):\n        self.aer_sim.run(self.quad_ham_evo_circuit).result()\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        self.one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        self.orbital_energies, self.orbital_rotation = np.linalg.eigh(\n            self.one_body_tensor\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        n_particles = n_alpha + n_beta\n        spin = n_alpha - n_beta\n        self.vec_fqe = fqe.Wavefunction([[n_particles, spin, norb]])\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_fqe.set_wfn(\n            strategy=\"from_data\",\n            raw_data={(n_particles, spin): self.vec.reshape(dim_a, dim_b).copy()},\n        )\n        self.fqe_ham = RestrictedHamiltonian((self.one_body_tensor,))\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                self.vec, norb=norb, nelec=self.nelec\n            )\n            circuit = num_op_sum_evo_circuit(\n                self.orbital_energies,\n                initial_state,\n                1.0,\n                norb=norb,\n                orbital_rotation=self.orbital_rotation,\n            )\n            self.quad_ham_evo_circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "quad_ham_evo.QuadHamEvoBenchmark.time_quad_ham_evolution_qiskit", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "c57ac82719d2a2f7c30ebff90dd283586b04b232cc2d7f205ed7549045000d0c", "warmup_time": -1}, "rust.RustBenchmark.time_apply_givens_rotation_in_place_python": {"code": "class RustBenchmark:\n    def time_apply_givens_rotation_in_place_python(self, *_):\n        apply_givens_rotation_in_place_slow(\n            self.vec_as_mat,\n            c=0.5,\n            s=(1j) ** 0.5 * np.sqrt(0.75),\n            slice1=self.slice1,\n            slice2=self.slice2,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        rng = np.random.default_rng()\n    \n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_as_mat = self.vec.reshape((dim_a, dim_b))\n    \n        indices = _zero_one_subspace_indices(self.norb, self.nelec[0], (1, 2))\n        self.slice1 = indices[: len(indices) // 2]\n        self.slice2 = indices[len(indices) // 2 :]", "min_run_count": 2, "name": "rust.RustBenchmark.time_apply_givens_rotation_in_place_python", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "e58784ec9943245b27f40334141920299cc473f378eb406bd27d7b2783850522", "warmup_time": -1}, "rust.RustBenchmark.time_apply_givens_rotation_in_place_rust": {"code": "class RustBenchmark:\n    def time_apply_givens_rotation_in_place_rust(self, *_):\n        apply_givens_rotation_in_place(\n            self.vec_as_mat,\n            c=0.5,\n            s=(1j) ** 0.5 * np.sqrt(0.75),\n            slice1=self.slice1,\n            slice2=self.slice2,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        rng = np.random.default_rng()\n    \n        self.vec = ffsim.random.random_statevector(\n            ffsim.dim(self.norb, self.nelec), seed=rng\n        )\n        dim_a, dim_b = ffsim.dims(self.norb, self.nelec)\n        self.vec_as_mat = self.vec.reshape((dim_a, dim_b))\n    \n        indices = _zero_one_subspace_indices(self.norb, self.nelec[0], (1, 2))\n        self.slice1 = indices[: len(indices) // 2]\n        self.slice2 = indices[len(indices) // 2 :]", "min_run_count": 2, "name": "rust.RustBenchmark.time_apply_givens_rotation_in_place_rust", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "0b7e6fb3fe123033a9689da7304948f1db67433c4ed5a67402e9194cfbbce141", "warmup_time": -1}, "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized": {"code": "class TrotterBenchmark:\n    def time_simulate_trotter_double_factorized(self, *_):\n        ffsim.simulate_trotter_double_factorized(\n            self.vec,\n            self.df_hamiltonian,\n            self.time,\n            norb=self.norb,\n            nelec=self.nelec,\n            n_steps=self.n_steps,\n            order=0,\n            copy=False,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        self.time = 1.0\n        self.n_steps = 3\n        rank = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            self.norb, rank=rank, seed=rng, dtype=float\n        )\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor, two_body_tensor=two_body_tensor\n        )\n        self.df_hamiltonian = (\n            ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian(\n                mol_hamiltonian, max_vecs=rank\n            )\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        self.vec_fqe = fqe.Wavefunction([[n_alpha + n_beta, n_alpha - n_beta, norb]])\n        self.vec_fqe.set_wfn(strategy=\"hartree-fock\")\n        low_rank_trotter = LowRankTrotter(\n            oei=one_body_tensor,\n            tei=np.asarray(two_body_tensor.transpose(0, 2, 3, 1), order=\"C\"),\n        )\n        (\n            self.basis_change_unitaries,\n            self.diag_coulomb_mats,\n        ) = low_rank_trotter.prepare_trotter_sequence(self.time)\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                ffsim.hartree_fock_state(self.norb, self.nelec),\n                norb=self.norb,\n                nelec=self.nelec,\n            )\n            qubits = QuantumRegister(2 * norb)\n            trotter_step = AsymmetricLowRankTrotterStepJW(qubits, self.df_hamiltonian)\n            circuit = QuantumCircuit(qubits)\n            circuit.set_statevector(initial_state)\n            for instruction in simulate_trotter(\n                trotter_step,\n                self.time,\n                n_steps=self.n_steps,\n            ):\n                circuit.append(instruction)\n            circuit.save_state()\n            self.circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "8b63af3333d435e46271b0d451b2c60222fbae151e875c579d394ab955d320a3", "warmup_time": -1}, "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_fqe": {"code": "class TrotterBenchmark:\n    @skip_for_params([(16, 0.5)])\n    def time_simulate_trotter_double_factorized_fqe(self, *_):\n        simulate_trotter_double_factorized_fqe(\n            self.vec_fqe,\n            time=self.time,\n            n_steps=self.n_steps,\n            basis_change_unitaries=self.basis_change_unitaries,\n            diag_coulomb_mats=self.diag_coulomb_mats,\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        self.time = 1.0\n        self.n_steps = 3\n        rank = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            self.norb, rank=rank, seed=rng, dtype=float\n        )\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor, two_body_tensor=two_body_tensor\n        )\n        self.df_hamiltonian = (\n            ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian(\n                mol_hamiltonian, max_vecs=rank\n            )\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        self.vec_fqe = fqe.Wavefunction([[n_alpha + n_beta, n_alpha - n_beta, norb]])\n        self.vec_fqe.set_wfn(strategy=\"hartree-fock\")\n        low_rank_trotter = LowRankTrotter(\n            oei=one_body_tensor,\n            tei=np.asarray(two_body_tensor.transpose(0, 2, 3, 1), order=\"C\"),\n        )\n        (\n            self.basis_change_unitaries,\n            self.diag_coulomb_mats,\n        ) = low_rank_trotter.prepare_trotter_sequence(self.time)\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                ffsim.hartree_fock_state(self.norb, self.nelec),\n                norb=self.norb,\n                nelec=self.nelec,\n            )\n            qubits = QuantumRegister(2 * norb)\n            trotter_step = AsymmetricLowRankTrotterStepJW(qubits, self.df_hamiltonian)\n            circuit = QuantumCircuit(qubits)\n            circuit.set_statevector(initial_state)\n            for instruction in simulate_trotter(\n                trotter_step,\n                self.time,\n                n_steps=self.n_steps,\n            ):\n                circuit.append(instruction)\n            circuit.save_state()\n            self.circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_fqe", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "33ab232bc3127507f450015f2896d6337eff0ed9cf44d950423f9b4827584b69", "warmup_time": -1}, "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_qiskit": {"code": "class TrotterBenchmark:\n    @skip_for_params([(16, 0.25), (16, 0.5)])\n    def time_simulate_trotter_double_factorized_qiskit(self, *_):\n        self.aer_sim.run(self.circuit).result()\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        self.time = 1.0\n        self.n_steps = 3\n        rank = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        one_body_tensor = ffsim.random.random_hermitian(self.norb, seed=rng)\n        two_body_tensor = ffsim.random.random_two_body_tensor(\n            self.norb, rank=rank, seed=rng, dtype=float\n        )\n        mol_hamiltonian = ffsim.MolecularHamiltonian(\n            one_body_tensor=one_body_tensor, two_body_tensor=two_body_tensor\n        )\n        self.df_hamiltonian = (\n            ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian(\n                mol_hamiltonian, max_vecs=rank\n            )\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)\n    \n        # prepare FQE\n        n_alpha, n_beta = self.nelec\n        self.vec_fqe = fqe.Wavefunction([[n_alpha + n_beta, n_alpha - n_beta, norb]])\n        self.vec_fqe.set_wfn(strategy=\"hartree-fock\")\n        low_rank_trotter = LowRankTrotter(\n            oei=one_body_tensor,\n            tei=np.asarray(two_body_tensor.transpose(0, 2, 3, 1), order=\"C\"),\n        )\n        (\n            self.basis_change_unitaries,\n            self.diag_coulomb_mats,\n        ) = low_rank_trotter.prepare_trotter_sequence(self.time)\n        fqe.settings.use_accelerated_code = True\n    \n        # prepare Qiskit\n        if norb <= 12:\n            self.aer_sim = AerSimulator(max_parallel_threads=OMP_NUM_THREADS)\n            initial_state = ffsim.qiskit.ffsim_vec_to_qiskit_vec(\n                ffsim.hartree_fock_state(self.norb, self.nelec),\n                norb=self.norb,\n                nelec=self.nelec,\n            )\n            qubits = QuantumRegister(2 * norb)\n            trotter_step = AsymmetricLowRankTrotterStepJW(qubits, self.df_hamiltonian)\n            circuit = QuantumCircuit(qubits)\n            circuit.set_statevector(initial_state)\n            for instruction in simulate_trotter(\n                trotter_step,\n                self.time,\n                n_steps=self.n_steps,\n            ):\n                circuit.append(instruction)\n            circuit.save_state()\n            self.circuit = transpile(circuit, self.aer_sim)", "min_run_count": 2, "name": "trotter.TrotterBenchmark.time_simulate_trotter_double_factorized_qiskit", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "5b69ea3ee4f8de71d94602225c926b04336d03c5952f561ae6424a97176ebaeb", "warmup_time": -1}, "variational.HopGateAnsatzBenchmark.time_hop_gate_ansatz": {"code": "class HopGateAnsatzBenchmark:\n    def time_hop_gate_ansatz(self, *_):\n        ffsim.apply_unitary(\n            self.vec, self.operator, norb=self.norb, nelec=self.nelec, copy=False\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(norb, self.nelec)\n        interaction_pairs = list(itertools.combinations(range(norb), 2))\n        thetas = rng.uniform(-np.pi, np.pi, size=len(interaction_pairs))\n        self.operator = ffsim.HopGateAnsatzOperator(\n            norb, interaction_pairs, thetas=thetas\n        )\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "variational.HopGateAnsatzBenchmark.time_hop_gate_ansatz", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "caa743469d9cce14a658b02b7d99eb96790891ee1613eef779dca90857a9a553", "warmup_time": -1}, "variational.UCJBenchmark.time_ucj": {"code": "class UCJBenchmark:\n    def time_ucj(self, *_):\n        ffsim.apply_unitary(\n            self.vec, self.operator, norb=self.norb, nelec=self.nelec, copy=False\n        )\n\n    def setup(self, norb: int, filling_fraction: float):\n        # set benchmark parameters\n        self.norb = norb\n        nocc = int(norb * filling_fraction)\n        self.nelec = (nocc, nocc)\n        n_reps = 3\n    \n        # initialize test objects\n        rng = np.random.default_rng()\n        self.vec = ffsim.hartree_fock_state(self.norb, self.nelec)\n        t2 = ffsim.random.random_t2_amplitudes(self.norb, nocc, seed=rng, dtype=float)\n        self.operator = ffsim.UCJOperator.from_t_amplitudes(t2, n_reps=n_reps)\n    \n        # initialize ffsim cache\n        ffsim.init_cache(self.norb, self.nelec)", "min_run_count": 2, "name": "variational.UCJBenchmark.time_ucj", "number": 0, "param_names": ["norb", "filling_fraction"], "params": [["4", "8"], ["0.25", "0.5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "5cb72dfb3cfbf5d0857558fb2e7cec1fb3695a105864bba5748f685df32a549e", "warmup_time": -1}}, "machines": {"li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com": {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz", "machine": "li-7d1035cc-1f16-11b2-a85c-8530f9357908.ibm.com", "num_cpu": "8", "os": "Linux 6.5.5-200.fc38.x86_64", "ram": "16013132", "version": 1}}, "tags": {"v0.0.0-alpha": 293, "v0.0.1-alpha": 294, "v0.0.10-alpha": 633, "v0.0.11-alpha": 646, "v0.0.12": 650, "v0.0.13": 656, "v0.0.14": 692, "v0.0.15": 733, "v0.0.16": 756, "v0.0.17": 784, "v0.0.18": 838, "v0.0.19": 861, "v0.0.2-alpha": 295, "v0.0.20": 868, "v0.0.21": 877, "v0.0.22": 934, "v0.0.23": 944, "v0.0.24": 979, "v0.0.25": 1023, "v0.0.26": 1073, "v0.0.27": 1112, "v0.0.28": 1148, "v0.0.29": 1304, "v0.0.3-alpha": 328, "v0.0.30": 1320, "v0.0.31": 1356, "v0.0.32": 1378, "v0.0.33": 1393, "v0.0.34": 1420, "v0.0.4-alpha": 337, "v0.0.5-alpha": 357, "v0.0.6-alpha": 372, "v0.0.7-alpha": 397, "v0.0.8-alpha": 427, "v0.0.9-alpha": 490}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}